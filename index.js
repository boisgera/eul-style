#!/usr/bin/env node
// Generated by CoffeeScript 1.12.7
(function() {
  var $, Badge, ES, _, bibliography, code, coffeescript, color, containsTombstone, cssify, defaults, exec, execSync, figure, fontAwesome, footnotes, fs, header, headings, image, insert_script, jQuery, jquery, jsdom, layout, links, lists, main, math, notes, parseArgs, path, previews, process, proofs, quote, ref, removeEmptySections, sanitize, split_types_text, table, theme, title_case, toc, trim_period, type, typography, width_percentage, window,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  fs = require("fs");

  path = require("path");

  process = require("process");

  ref = require("child_process"), exec = ref.exec, execSync = ref.execSync;

  coffeescript = require("coffee-script");

  jquery = require("jquery");

  jsdom = require("jsdom");

  parseArgs = require("minimist");

  _ = require("lodash");

  cssify = require("@boisgera/cssify");

  type = function(item) {
    return Object.prototype.toString.call(item).slice(8, -1).toLowerCase();
  };

  String.prototype.capitalize = function() {
    return this.slice(0, 1).toUpperCase() + this.slice(1);
  };

  String.prototype.decapitalize = function() {
    this.slice(0, 1).toLowerCase() + this.slice(1);
    return this.charAt(0).toLowerCase() + this.slice(1);
  };

  String.prototype.startsWith = function(string) {
    return this.slice(0, string.length) === string;
  };

  insert_script = function(arg) {
    var script, src, uri;
    uri = arg.uri, src = arg.src;
    script = window.document.createElement("script");
    script.type = "text/javascript";
    if (!!uri) {
      script.src = uri;
    }
    if (!!uri) {
      script.text = src;
    }
    return window.document.head.appendChild(script);
  };

  defaults = {
    css: function() {
      return {
        "*": {
          margin: 0,
          padding: 0,
          border: 0,
          boxSizing: "content-box",
          fontSize: "100%",
          font: "inherit",
          verticalAlign: "baseline"
        },
        html: {
          lineHeight: 1
        },
        "ol, ul": {
          listStyle: "none"
        },
        "blockquote, q": {
          "quotes": "none",
          "&:before": {
            content: "none"
          },
          "&:after": {
            content: "none"
          }
        },
        table: {
          borderCollapse: "collapse",
          borderSpacing: 0
        }
      };
    },
    html: function() {
      return void 0;
    }
  };

  color = {
    css: function() {
      return {
        html: {
          "--color": "black"
        }
      };
    }
  };


  /*
  NOTA: We use quantities as numbers, without explicit units in javascript
  since this is the only sane way to make computations.
  OTOH  we have to track/remember what their unit is and
  convert it to a string with the appropriate unit for CSS.
  In CSS, we can also do some (limited) computations with `calc`
  if this is needed.
  
  When we need these values for other components, should we pull
  the info from js or from css? If we do from JS, we need to add
  the unit back but we have a decent syntax otherwise (namespaced name, etc.); 
  from CSS we have to use the weird calc/var and "--" notation combo
  but it may change at runtime (*maybe*, if we put ALMOST ALL computations
  in CSS, but we don't use this, right? And we don't need this either!)
   */

  typography = (function() {
    var baseFontSize, baseLineHeight, family, large, medium, scaleRatio, small, xLarge;
    baseFontSize = 24;
    baseLineHeight = 1.5 * baseFontSize;
    scaleRatio = Math.sqrt(2);
    small = Math.round(baseFontSize / scaleRatio);
    medium = Math.round(baseFontSize);
    large = Math.round(baseFontSize * scaleRatio);
    xLarge = Math.round(baseFontSize * scaleRatio * scaleRatio);
    family = function(options) {
      var name;
      if (options == null) {
        options = {};
      }
      if (options.serif == null) {
        options.serif = true;
      }
      if (options.smallCaps == null) {
        options.smallCaps = false;
      }
      name = "Alegreya";
      if (!options.serif) {
        name += " Sans";
      }
      if (options.smallCaps) {
        name += " SC";
      }
      name = "'" + name + "'";
      if (options.serif) {
        name += ", serif";
      } else {
        name += ", sans-serif";
      }
      return name;
    };
    return {
      baseFontSize: baseFontSize,
      baseLineHeight: baseLineHeight,
      scaleRatio: scaleRatio,
      small: small,
      medium: medium,
      large: large,
      xLarge: xLarge,
      family: family,
      html: function() {
        var link;
        family = "Alegreya: 400,700,900,400italic,700italic,900italic" + "|Alegreya+SC:400,700,900,400italic,700italic,900italic" + "|Alegreya+Sans:100,300,400,500,700,800,900,100italic,300italic,400italic,500italic,700italic,800italic,900italic" + "|Alegreya+Sans+SC:100,300,400,500,700,800,900,100italic,300italic,400italic,500italic,700italic,800italic,900italic";
        link = $("<link>", {
          href: "https://fonts.googleapis.com/css?family=" + family,
          rel: "stylesheet",
          type: "text/css"
        });
        return $("head").append(link);
      },
      css: function() {
        return {
          html: {
            "--base-font-size": baseFontSize + "px",
            "--base-line-height": baseLineHeight + "px",
            "--scale-ratio": scaleRatio,
            "--small": small + "px",
            "--medium": medium + "px",
            "--large": large + "px",
            "--x-large": xLarge + "px",
            lineHeight: "var(--base-line-height)",
            fontSize: medium + "px",
            fontFamily: family({
              serif: true
            }),
            fontStyle: "normal",
            fontWeight: "normal",
            em: {
              fontStyle: "italic"
            },
            strong: {
              fontWeight: "bold"
            },
            textRendering: "optimizeLegibility",
            textAlign: "left",
            "p, .p": {
              marginBottom: "var(--base-line-height)",
              textAlign: "justify",
              hyphens: "auto",
              MozHyphens: "auto"
            },
            section: {
              marginBottom: "var(--base-line-height)"
            }
          }
        };
      }
    };
  })();

  layout = {
    css: function() {
      return {
        html: {
          body: {
            boxSizing: "content-box",
            maxWidth: "32em",
            margin: "auto",
            padding: "var(--base-line-height)"
          }
        }
      };
    }
  };

  sanitize = function($, elt) {
    var children, first, second;
    children = elt.children();
    if (children.length >= 2) {
      first = children[0];
      second = children[1];
      if (first.tagName === "A" && second.tagName === "A") {
        return $(first).remove();
      }
    }
  };

  removeEmptySections = function(toc) {
    var j, len, li, ref1, results;
    ref1 = toc.find("li");
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      li = ref1[j];
      if ($(li).find("a").text() === "") {
        results.push($(li).remove());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  trim_period = function(text) {
    if (text[text.length - 1] === "." && text[text.length - 2] !== ".") {
      text = text.slice(0, -1);
    }
    return text;
  };

  split_types_text = function(text) {
    var parts, pattern, ref1, s, section_types, sep_regexp, separators, types;
    section_types = "Theorem Lemma Proposition Corollary Definition Remark Example Examples Question Questions Answer Answers".split(" ");
    separators = "–&,";
    pattern = "(" + ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = separators.length; j < len; j++) {
        s = separators[j];
        results.push(s);
      }
      return results;
    })()).join("|") + ")";
    sep_regexp = new RegExp(pattern);
    parts = text.split(sep_regexp);
    types = [];
    while (parts.length > 0) {
      if (ref1 = parts[0].trim(), indexOf.call(section_types, ref1) >= 0) {
        types.push(parts.shift().trim());
        parts.shift();
      } else {
        break;
      }
    }
    text = parts.join("").trim();
    return [types, text];
  };

  Badge = function(label) {
    label = label.slice(0, 3).toLowerCase();
    return $("<span class='badge'>" + label + "<span>");
  };

  toc = {
    html: function() {
      var anchor, anchors, details, j, k, len, len1, li, n, ref1, section, subtext, text, top_lis, types;
      toc = $("nav#TOC");
      if (toc.length) {
        toc.find("li").each(function() {
          return sanitize($, $(this));
        });
        removeEmptySections(toc);
      }
      if (toc.length) {
        toc.find("li").each(function() {
          return sanitize($, $(this));
        });
        top_lis = toc.children("ul").children("li");
        top_lis.addClass("top-li");
        anchors = toc.find("a");
        for (j = 0, len = anchors.length; j < len; j++) {
          anchor = anchors[j];
          text = $(anchor).text();
          if (text.startsWith("Proof")) {
            $(anchor).remove();
          }
          text = trim_period(text);
          ref1 = split_types_text(text), types = ref1[0], subtext = ref1[1];
          if (types.length) {
            $(anchor).html(subtext || text);
            $(anchor).parent().prepend(Badge(types[0]));
          }
        }
        for (n = k = 0, len1 = top_lis.length; k < len1; n = ++k) {
          li = top_lis[n];
          $(li).prepend("<p class='section-flag'>section " + (n + 1) + "</p>");
        }
        section = $("<section id='contents' class='level1' ></section>");
        section.append(toc.clone());
        details = $('<details style="margin-bottom:calc(2 * var(--base-line-height))"> <summary><a href="#contents"><span style="font-weight:bold">Contents</span></a></summary> </detail>');
        details.append(section);
        return toc.replaceWith(details);
      }
    },
    css: function() {
      return {
        "p.section-flag": {
          margin: "0"
        },
        "nav#TOC": {
          "> ul": {
            position: "relative",
            fontWeight: "bold",
            "> *": {
              marginBottom: "var(--base-line-height)"
            },
            li: {
              listStyleType: "none",
              marginLeft: 0,
              paddingLeft: 0
            },
            ul: {
              li: {
                marginLeft: "var(--base-line-height)",
                fontWeight: "normal"
              }
            },
            "> li.top-li": {
              marginBottom: 0,
              paddingBottom: "var(--base-line-height)",
              borderWidth: "2px 0 0 0",
              borderStyle: "solid",
              "&:last-child": {
                borderWidth: "2px 0 2px 0"
              }
            }
          }
        },
        ".badge": {
          position: "relative",
          bottom: "0.13em",
          fontFamily: typography.family({
            serif: false,
            smallCaps: true
          }),
          fontWeight: "300",
          fontSize: "var(--small)",
          display: "inline-block",
          lineHeight: "1.2em",
          height: "1.2em",
          width: "2em",
          textAlign: "center",
          borderRadius: "2px",
          backgroundColor: "#f0f0f0",
          verticalAlign: "baseline",
          boxShadow: "0px 1.0px 1.0px #aaa",
          marginRight: "1em"
        },
        ".section-flag": {
          lineHeight: "var(--base-line-height)",
          fontSize: "var(--small)",
          fontWeight: "300",
          fontFamily: typography.family({
            serif: false,
            smallCaps: true
          }),
          marginBottom: 0
        }
      };
    },
    js: function() {
      return {
        src: "js/toc.js"
      };
    }
  };

  notes = {
    html: function() {
      var toc_;
      notes = $("section.footnotes");
      notes.attr({
        id: "notes"
      });
      if (notes.length) {
        notes.prepend($("<h1><a href='#notes'>Notes</a></h1>"));
        toc_ = $("nav#TOC");
        if (toc_.length > 0) {
          return toc_.children().first().append($("<li><a href='#notes'>Notes</a></li>"));
        }
      }
    }
  };

  header = {
    css: function() {
      return {
        body: {
          "> header, > .header, > #header": {
            marginTop: "calc(2 * var(--base-line-height))",
            marginBottom: "calc(2 * var(--base-line-height))",
            h1: {
              textAlign: "left",
              fontSize: typography.xLarge + "px",
              lineHeight: "calc(1.5 * var(--base-line-height))",
              marginTop: 0.0,
              marginBottom: "var(--base-line-height)",
              fontWeight: "bold"
            },
            ".author": {
              fontSize: typography.medium + "px",
              lineHeight: "calc(1 * var(--base-line-height))",
              marginBottom: "calc(0.5 * var(--base-line-height))",
              fontWeight: "normal"
            },
            ".date": {
              fontFamily: typography.family({
                smallCaps: true
              }),
              lineHeight: "calc(1 * var(--base-line-height))",
              fontSize: typography.medium + "px",
              fontWeight: "normal",
              marginBottom: "calc(0.5 * var(--base-line-height))",
              float: "none"
            }
          }
        }
      };
    }
  };

  headings = {
    css: function() {
      return {
        h1: {
          fontSize: typography.large + "px",
          fontWeight: "bold",
          lineHeight: "calc(1.25 * var(--base-line-height))",
          marginTop: "calc(2.00 * var(--base-line-height))",
          marginBottom: "calc(0.75 * var(--base-line-height))"
        },
        h2: {
          fontSize: typography.medium + "px",
          fontWeight: "bold",
          lineHeight: "calc(1 * var(--base-line-height))",
          marginBottom: "calc(0.5 * var(--base-line-height))"
        },
        "h3, h4, h5, h6": {
          fontSize: typography.medium + "px",
          fontWeight: "bold",
          marginRight: "1em",
          display: "inline"
        }
      };
    },
    html: function() {
      var heading, j, len, next, p, results, subsubheadings;
      subsubheadings = $("h3, h4, h5, h6");
      results = [];
      for (j = 0, len = subsubheadings.length; j < len; j++) {
        heading = subsubheadings[j];
        if ($(heading).find("a").first().text() === "") {
          $(heading).css({
            marginRight: "0"
          });
        }
        next = $(heading).next();
        if (next.is("p")) {
          next.replaceWith("<div class='p'>" + next.html() + "</span>");
          p = $(heading).next();
          p.prepend(heading);
        }
        if (next.is("ul, ol")) {
          results.push($("<br>").insertAfter($(heading)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  links = {
    css: function() {
      return {
        a: {
          cursor: "pointer",
          textDecoration: "none",
          outline: 0,
          "&:hover": {
            textDecoration: "none"
          },
          "&:link": {
            color: "var(--color)"
          },
          "&:visited": {
            color: "var(--color)"
          }
        }
      };
    }
  };

  footnotes = {
    css: function() {
      return {
        sup: {
          verticalAlign: "super",
          lineHeight: 0
        }
      };
    }
  };

  lists = {
    css: function() {
      return {
        li: {
          listStyleType: "none",
          listStyleImage: "none",
          listStylePosition: "outside",
          marginLeft: "var(--base-line-height)",
          paddingLeft: "0.5em"
        },
        ul: {
          li: {
            listStyle: "disc"
          }
        },
        ol: {
          li: {
            listStyle: "decimal"
          }
        }
      };
    }
  };

  quote = {
    css: function() {
      return {
        blockquote: {
          borderLeftWidth: "thick",
          borderLeftStyle: "solid",
          borderLeftColor: "black",
          padding: "var(--base-line-height)",
          marginBottom: "var(--base-line-height)",
          "p:last-child": {
            marginBottom: "0px"
          }
        }
      };
    }
  };

  code = {
    html: function() {
      var family, link;
      family = "Inconsolata:400,700";
      link = $("<link>", {
        href: "https://fonts.googleapis.com/css?family=" + family,
        rel: "stylesheet",
        type: "text/css"
      });
      return $("head").append(link);
    },
    css: function() {
      return {
        code: {
          fontSize: typography.medium + "px",
          fontFamily: "Inconsolata"
        },
        pre: {
          overflowX: "auto",
          backgroundColor: "#ebebeb",
          marginBottom: "var(--base-line-height)",
          paddingLeft: "var(--base-line-height)",
          paddingRight: "var(--base-line-height)",
          paddingTop: "var(--base-line-height)",
          paddingBottom: "var(--base-line-height)"
        }
      };
    }
  };

  width_percentage = function(image_filename) {
    var density, latex_width_in, ppi, width_in, width_px;
    latex_width_in = 345.0 / 72.27;
    density = execSync("identify -format '%x' '" + image_filename + "'").toString();
    density = density.split(" ")[0];
    ppi = density * 2.54;
    width_px = execSync("identify -format '%w' '" + image_filename + "'").toString();
    width_in = width_px / ppi;
    return Math.min(100.0 * width_in / latex_width_in, 100.0);
  };

  image = {
    html: function() {
      var filename, images, img, j, len, ref1, results;
      images = $("img");
      results = [];
      for (j = 0, len = images.length; j < len; j++) {
        img = images[j];
        filename = $(img).attr("src");
        if ((ref1 = filename.slice(-3)) === "jpg" || ref1 === "png") {
          results.push($(img).css("width", width_percentage(filename) + "%"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    css: function() {
      return {
        img: {
          display: "block",
          marginLeft: "auto",
          marginRight: "auto",
          width: "100%",
          height: "auto"
        }
      };
    }
  };

  figure = {
    css: function() {
      return {
        figure: {
          marginBottom: "var(--base-line-height)",
          textAlign: "center"
        },
        figcaption: {
          display: "inline-block",
          fontStyle: "italic",
          textAlign: "justify"
        }
      };
    }
  };

  table = {
    html: function() {
      return $("table").wrap("<div class='table'></div>");
    },
    css: function() {
      return {
        ".table": {
          overflowX: "auto",
          overflowY: "hidden",
          width: "100%",
          marginBottom: "var(--base-line-height)"
        },
        table: {
          padding: 0,
          marginLeft: "auto",
          marginRight: "auto",
          borderSpacing: "1em " + (typography.baseLineHeight - typography.baseFontSize) + "px",
          borderCollapse: "collapse",
          borderTop: "medium solid black",
          borderBottom: "medium solid black"
        },
        thead: {
          borderBottom: "medium solid black"
        },
        "td, th": {
          padding: 0.5 * (typography.baseLineHeight - typography.baseFontSize) + "px" + " 0.5em"
        }
      };
    }
  };

  math = {
    css: function() {
      return {
        ".MJXc-display": {
          overflowX: "auto",
          overflowY: "hidden",
          width: "100%"
        }
      };
    },
    html: function() {
      var old;
      old = $("head script").filter(function(i, elt) {
        var src;
        src = $(elt).attr("src");
        return /mathjax/.test(src);
      });
      old.remove();
      return insert_script({
        uri: "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML",
        src: "MathJax.Hub.Config({ jax: ['output/CommonHTML'], CommonHTML: { scale: 100, linebreaks: {automatic: false}, mtextFontInherit: true} });"
      });
    }
  };

  fontAwesome = {
    html: function() {
      var link;
      link = $("<link>", {
        rel: "stylesheet",
        href: "https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"
      });
      return $("head").append(link);
    }
  };

  jQuery = {
    html: function() {
      return insert_script({
        uri: "https://code.jquery.com/jquery-3.0.0.min.js"
      });
    }
  };

  title_case = function(text) {
    var first, item, j, k, len, len1, match, new_parts, no_cap, output, part, parts, pattern, second, seps;
    no_cap = "a an the and but or for nor aboard about above across after against along amid among around as at atop before behind below beneath beside between beyond by despite down during for from in inside into like near of off on onto out outside over past regarding round since than through throughout till to toward under unlike until up upon with within without".split(" ");
    no_cap = no_cap.concat(["un", "une", "de", "du", "des", "le", "la", "les", "d", "l", "et", "ou", "ni", "mais", "donc", "car", "sur", "vers", "entre", "avec", "sans", "par"]);
    parts = text.split(/[\s,;\-:.!?"'’&]+/);
    seps = text.split(/[^\s,;\-:.!?"'’&]+/);
    new_parts = [];
    for (j = 0, len = parts.length; j < len; j++) {
      part = parts[j];
      match = false;
      for (k = 0, len1 = no_cap.length; k < len1; k++) {
        item = no_cap[k];
        if (type(item) === "string") {
          pattern = new RegExp("^" + item + "$");
        } else {
          pattern = item;
        }
        if (part.match(pattern)) {
          match = true;
          break;
        }
      }
      if (!match) {
        part = part.capitalize();
      }
      new_parts.push(part);
    }
    output = "";
    if (seps[0] === "") {
      first = seps;
      second = new_parts;
    } else {
      first = new_parts;
      second = seps;
    }
    while (first.length) {
      output += first.shift();
      if (second.length) {
        output += second.shift();
      }
    }
    return output;
  };

  bibliography = {
    html: function(arg) {
      var authors, b64, b64Data, b64Prefix, bib, div, entry, find_entry, id, j, k, l, len, len1, len2, li, list, ref1, ref2, ref_ids, refs, results, short_title, year;
      bib = arg.bib;
      find_entry = function(id) {
        var entry, j, len;
        for (j = 0, len = bib.length; j < len; j++) {
          entry = bib[j];
          if (entry.id === id) {
            return entry;
          }
        }
        return void 0;
      };
      short_title = function(text) {
        var parts;
        parts = text.split(".");
        return parts[0];
      };
      authors = function(entry) {
        var author, dp, i, j, len, ref1, s;
        s = "";
        ref1 = entry.author;
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          author = ref1[i];
          if (i > 0) {
            if (i < entry.author.length - 1) {
              s += ", ";
            }
            ({
              "else": s += " and "
            });
          }
          if (author.literal != null) {
            s += author.literal;
          } else {
            dp = author["dropping-particle"] != null ? " " + author["dropping-particle"] : "";
            s += author.given + dp + " " + author.family;
          }
        }
        return s;
      };
      year = function(entry) {
        var ref1, ref2, ref3;
        return entry != null ? (ref1 = entry.issued) != null ? (ref2 = ref1["date-parts"]) != null ? (ref3 = ref2[0]) != null ? ref3[0] : void 0 : void 0 : void 0 : void 0;
      };
      refs = $("#refs");
      ref_ids = [];
      ref1 = refs.children();
      for (j = 0, len = ref1.length; j < len; j++) {
        div = ref1[j];
        ref_ids.push(div.getAttribute("id").slice(4));
      }
      refs.html("<ol></ol>");
      list = refs.find("ol");
      for (k = 0, len1 = ref_ids.length; k < len1; k++) {
        id = ref_ids[k];
        list.append("<li id='ref-" + id + "' style='margin-bottom:0.75em'></li>");
      }
      ref2 = list.children();
      results = [];
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        li = ref2[l];
        id = li.getAttribute("id").slice(4);
        entry = find_entry(id);
        b64Data = Buffer(JSON.stringify(entry, null, 2)).toString("base64");
        b64Prefix = "data:application/json;charset=utf-8;fontSize64,";
        b64 = b64Prefix + b64Data;
        $(li).append("<em>" + title_case(short_title(entry.title)) + "</em>");
        $(li).append("<br>");
        $(li).append(authors(entry) + ", " + year(entry) + ".");
        $(li).append("<br>");
        $(li).append("JSON: <a href='" + b64 + "'><i style='font-size:18px;position:relative;bottom:0.05em;' class='fa fa-file-text-o'></i></a>&nbsp;");
        if (entry.URL != null) {
          $(li).append(" / URL: <a href='" + entry.URL + "'><i style='font-size:18px'class='fa fa-link'></i></a>");
        }
        if (entry.DOI != null) {
          results.push($(li).append("  / DOI: <a href='https://doi.org/" + entry.DOI + "'><i style='font-size:18px'class='fa fa-link'></i></a>"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  containsTombstone = function(elt) {
    if (elt[0].outerHTML.indexOf("\\blacksquare") > -1) {
      return true;
    }
    return false;
  };

  proofs = {
    html: function() {
      var j, k, l, len, len1, len2, newSection, paragraph, proofSections, ref1, results, section, sections, split, text;
      sections = $("section");
      proofSections = [];
      for (j = 0, len = sections.length; j < len; j++) {
        section = sections[j];
        header = $(section).find("h3, h4, h5, h6").first();
        if (header.length) {
          text = header.text();
          if (text.slice(0, 5) === "Proof") {
            proofSections.push($(section));
          }
        }
      }
      results = [];
      for (k = 0, len1 = proofSections.length; k < len1; k++) {
        section = proofSections[k];
        split = false;
        newSection = $("<section></section>");
        ref1 = section.children();
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          paragraph = ref1[l];
          if (split) {
            newSection.append($(paragraph));
          } else if (containsTombstone($(paragraph))) {
            split = true;
          }
        }
        if (newSection.children().length > 0) {
          results.push(section.after(newSection));
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    js: function() {
      return {
        src: "js/proofs.js"
      };
    }
  };

  previews = {
    js: function() {
      return {
        src: "js/preview.js"
      };
    }
  };

  theme = [jQuery, defaults, typography, layout, header, headings, links, footnotes, lists, quote, code, image, figure, table, math, notes, toc, fontAwesome, bibliography, proofs, previews];

  ES = {
    cssify: function(options) {
      var css_, csss, elt, j, len, rules;
      csss = [];
      for (j = 0, len = theme.length; j < len; j++) {
        elt = theme[j];
        if (elt.css != null) {
          css_ = elt.css;
          css_ = css_(options);
          csss.push(css_);
        }
      }
      rules = _.merge.apply(_, [{}].concat(slice.call(csss)));
      return cssify(rules);
    },
    domify: function(options) {
      var elt, j, len, results;
      results = [];
      for (j = 0, len = theme.length; j < len; j++) {
        elt = theme[j];
        if (elt.html != null) {
          results.push(elt.html(options));
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    scriptify: function(options) {
      var elt, j, jsPath, jsSrc, len, results;
      results = [];
      for (j = 0, len = theme.length; j < len; j++) {
        elt = theme[j];
        if (elt.js != null) {
          jsPath = elt.js(options).src;
          jsPath = path.join(__dirname, jsPath);
          jsSrc = fs.readFileSync(jsPath, "utf8");
          results.push(insert_script({
            src: jsSrc
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  window = void 0;

  $ = void 0;

  main = function() {
    var CSSFilename, HTMLFilename, aboutCSS, args, argv, bib_json, bibliographyFilename, bibliographyFilenames, css_text, doc, error, extra_bib_json, html, inputHTMLFilenames, j, len, link, options, outputString, style;
    argv = process.argv.slice(2);
    args = parseArgs(argv);
    HTMLFilename = args.h ? args.h : args.html;
    CSSFilename = args.s ? args.s : args.style;
    bibliographyFilenames = args.b ? args.b : args.bibliography;
    inputHTMLFilenames = args._;
    if (bibliographyFilenames != null) {
      if (type(bibliographyFilenames) === "string") {
        bibliographyFilenames = [bibliographyFilenames];
      }
      bib_json = [];
      for (j = 0, len = bibliographyFilenames.length; j < len; j++) {
        bibliographyFilename = bibliographyFilenames[j];
        extra_bib_json = JSON.parse(fs.readFileSync(bibliographyFilename, "utf8"));
        bib_json = bib_json.concat(bib_json, extra_bib_json);
      }
    }
    options = {
      bib: bib_json
    };
    aboutCSS = {};
    css_text = ES.cssify(options);
    if (CSSFilename != null) {
      try {
        fs.writeFileSync(CSSFilename, css_text, "utf-8");
      } catch (error1) {
        error = error1;
        console.log(error);
        process.exit(1);
      }
      aboutCSS.external = CSSFilename;
    } else {
      aboutCSS.inline = css_text;
    }
    if (inputHTMLFilenames.length || (HTMLFilename != null)) {
      jsdom.defaultDocumentFeatures = {
        FetchExternalResources: false,
        ProcessExternalResources: false,
        SkipExternalResources: /.*/
      };
      if (inputHTMLFilenames.length) {
        html = fs.readFileSync(inputHTMLFilenames[0], "utf-8");
        window = jsdom.jsdom().defaultView;
        doc = window.document.open("text/html", "replace");
        doc.write(html);
        doc.close();
      } else {
        window = jsdom.jsdom().defaultView;
      }
      $ = jquery(window);
      if (aboutCSS.external != null) {
        link = $("<link>", {
          href: aboutCSS.external,
          rel: "stylesheet",
          type: "text/css"
        });
        $("head").append(link);
      } else {
        style = $("<style></style>", {
          type: "text/css",
          text: aboutCSS.inline
        });
        $("head").append(style);
      }
      ES.domify(options);
      ES.scriptify(options);
      outputString = window.document.documentElement.outerHTML;
      if (HTMLFilename != null) {
        return fs.writeFileSync(HTMLFilename, outputString, "utf-8");
      } else {
        return console.log(outputString);
      }
    } else {
      if (aboutCSS.inline != null) {
        return console.log(aboutCSS.inline);
      }
    }
  };

  main();

}).call(this);
